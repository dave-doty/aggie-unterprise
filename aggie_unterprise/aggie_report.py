from dataclasses import dataclass
import argparse
import sys
import itertools
from pathlib import Path
from typing import Optional, List, TextIO
from aggie_unterprise import Summary

def main():
    args: CLArgs = parse_command_line_arguments()
    paths = find_filenames(args)
    print('Summarizing grant data from AggieEnterprise reports in these files:')
    print('  ' + ', '.join(path.name for path in paths))
    print(f'Output will be written to the ' + (f'file {args.outfile}' if args.outfile is not None else 'screen'))


    summaries = [Summary.from_file(path) for path in paths]
    summaries.sort(key=lambda s: s.date())
    if not args.sort_increasing_by_date:
        summaries.reverse()

    # For some reason using a context manager causes errors when writing to stdout.
    # Normally it works, but when I use PyInstaller to create an executable, it tries to close stdout
    # and causes an error
    file = open(args.outfile, 'w', encoding='utf-8') if args.outfile is not None else sys.stdout
    try:
        for sum_prev, sum_next in itertools.pairwise(summaries):
            if args.include_individual_summaries:
                print_indv_summary(file, sum_prev)
            if args.include_diffs:
                print_diff_summary(file, sum_prev, sum_next)
        if args.include_individual_summaries:
            last_summary = summaries[-1]
            print_indv_summary(file, last_summary)
    finally:
        if file is not sys.stdout:
            file.close()


def print_diff_summary(file: TextIO, sum_prev: Summary, sum_next: Summary) -> None:
    print(f'\nDifferences from {sum_prev.date()} to {sum_next.date()}:', file=file)
    print(sum_prev.diff_table(sum_next), file=file)


def print_indv_summary(file: TextIO, sum_prev: Summary) -> None:
    print(f'\nTotals for {sum_prev.date()}:', file=file)
    print(sum_prev, file=file)


@dataclass
class CLArgs:
    directory: Optional[str] = None
    """directory containing .xlsx files generated by aggie"""

    files: Optional[List[str]] = None
    """files specified by user in lieu of specifying directory"""

    outfile: Optional[str] = None
    """Name of file to print output; if not specified, output to the screen"""

    include_diffs: bool = True
    """Whether to include differences between files in the output"""

    include_individual_summaries: bool = True
    """Whether to include individual summaries in the output"""

    sort_increasing_by_date: bool = False
    """Whether to sort the files by date in increasing order"""


def parse_command_line_arguments() -> CLArgs:
    parser = argparse.ArgumentParser(
        description='''\
Processes reports generated by AggieEnterprise to summarize the useful data 
in them. By default it sorts the files by the date they were generated 
(according to cell A3 inside the spreadsheet file), and in that order
going backwards (so latest file is processed first), summarizes each file, 
as well as summarizing differences between adjacent files. 
If run with no arguments like this:

    C:\\reports> python aggie_report.py
    
or if you are using the executable aggie-report included with the
aggie_unterprise Python package, like this:

    C:\\reports> aggie-report

it will process all the .xlsx files in the current directory and print the 
results to the screen. Command line arguments can be used to customize this; 
type  `python aggie_report -h` to see all the options.''',
        # formatter_class=argparse.ArgumentDefaultsHelpFormatter)
        formatter_class=argparse.RawTextHelpFormatter)

    dir_files_group = parser.add_mutually_exclusive_group(required=False)

    dir_files_group.add_argument('-d', '--directory', type=str,
                        help='''\
directory to search for .xlsx files generated by 
AggieEnterprise. All .xlsx files are processed; to 
process only some files, list them explicitly after 
the flag -f. If neither -d nor -f is given, all 
.xlsx files in the current directory are processed.
This option is mutually exclusive with -f.''')

    dir_files_group.add_argument('-f', '--files', nargs='+', type=str,
                        help='''\
List of one or more .xlsx files generated by 
AggieEnterprise. To specify that all .xlsx files in 
a directory should be processed, use the -d option. 
This option is mutually exclusive with -d.''')

    parser.add_argument('-o', '--outfile', type=str,
                        help='''\
Name of file to print output; if not specified, 
print output to the screen.''')


    no_summary_group = parser.add_mutually_exclusive_group(required=False)

    no_summary_group.add_argument('-nd', '--no-diffs', action='store_true',
                        help='''\
If specified, do not include differences between 
adjacent files in the output. This option is
mutually exclusive with -ni.''')

    no_summary_group.add_argument('-ni', '--no-individual', action='store_true',
                        help='''\
If specified, do not include summaries for 
individual files. This option is mutually
exclusive with -nd.''')

    parser.add_argument('-s', '--sort-increasing-by-date', action='store_true',
                        help='''\
If specified, sort the files by date in increasing
order instead of the default, which is to sort by
date in decreasing order.''')

    args = parser.parse_args()
    clargs = CLArgs()

    if args.directory is not None:
        assert not args.files
        clargs.directory = args.directory

    if args.files is not None:
        assert not args.directory
        clargs.files = args.files

    if args.directory is None and args.files is None:
        clargs.directory = '.'

    if args.outfile:
        clargs.outfile = args.outfile

    clargs.include_diffs = not args.no_diffs
    clargs.include_individual_summaries = not args.no_individual
    assert clargs.include_diffs or clargs.include_individual_summaries

    clargs.sort_increasing_by_date = args.sort_increasing_by_date

    return clargs

def find_filenames(args) -> List[Path]:
    if args.files is not None:
        return [Path(file).resolve() for file in args.files]
    assert args.directory is not None
    directory = Path(args.directory).resolve()
    fns = [fn for fn in directory.iterdir() if fn.suffix == '.xlsx']
    if len(fns) == 0:
        raise FileNotFoundError(f'No .xlsx files found in directory "{directory}"')
    return fns

if __name__ == '__main__':
    main()